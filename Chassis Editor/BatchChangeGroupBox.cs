using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Drawing;

namespace Chassis_Editor
{

    class BatchChangeGroupBox
    {
        // This is an array of elements that are a label and button capable of representing a batch change
        BatchEditLine[] lines = new BatchEditLine[0];
        int maxLines = 10;
        int labelHeight = 22;
        int verticalSpacing = 8;
        public static int maxLabelLength = 38;
        int scrollIndex = 0;
        int x = 0;
        int y = 0;

        Button scrollUpButton;
        Button scrollDownButton;

        MainWindow mainWindow;

        // This is an array of changes generated by the user
        private BatchChange[] changes = new BatchChange[0];

        public BatchChangeGroupBox(int inX, int inY, MainWindow mainWindowIn)
        {
            Log.updateLog(Log.LogType.INITIALIZE, "Creating batchChangeGroupBox at " + inX + "," + inY);
            x = inX;
            y = inY;
            mainWindow = mainWindowIn;
            CreateScrollButtons();
        }

        public void CreateScrollButtons()
        {
            scrollUpButton = new Button();
            scrollUpButton.Image = Properties.Resources.ScrollUpButton;
            scrollUpButton.Click += new EventHandler(ScrollUp);
            scrollUpButton.Text = "";
            scrollUpButton.AutoSize = true;
            scrollUpButton.Location = new Point(x, y - scrollUpButton.Size.Height - (2 * verticalSpacing));

            scrollDownButton = new Button();
            scrollDownButton.Image = Properties.Resources.ScrollDownButton;
            scrollDownButton.Click += new EventHandler(ScrollDown);
            scrollDownButton.Text = "";
            scrollDownButton.AutoSize = true;
            scrollDownButton.Location = new Point(x,
                y + (maxLines * (labelHeight + verticalSpacing)));

            mainWindow.Controls.Add(scrollUpButton);
            mainWindow.Controls.Add(scrollDownButton);

            scrollUpButton.Hide();
            scrollDownButton.Hide();
        }

        public void RemoveBatchEditLine(Object sender, EventArgs e)
        {
            Button button = (Button)sender;
            BatchEditLine line = new BatchEditLine();

            Log.updateLog(Log.LogType.CLICK, "User has clicked a remove button");
            // Find the BatchEditLine that owns this button
            foreach(BatchEditLine l in lines)
            {
                if (l.MyButton(button))
                {
                    Log.updateLog(Log.LogType.CLICK, "Found button owner");
                    line = l;
                }
            }

            // If there are more changes than the max number of lines displayed, then we should not yet remove a line
            if (changes.Length - 1 < maxLines)
            {
                Log.updateLog(Log.LogType.CLICK, "Removing the last line");
                int numLines = lines.Length;
                Log.updateLog(Log.LogType.CLICK, "Number of lines before removal: " + numLines);
                if (numLines == 0)
                    return;

                BatchEditLine[] newLines = new BatchEditLine[numLines - 1];

                // Doesn't matter which one was clicked, we'll just update the text so that the last box can be removed
                for(int i = 0; i < newLines.Length; i++)
                {
                    newLines[i] = lines[i];
                }

                Log.updateLog(Log.LogType.CLICK, "Removing Controls of last line");
                lines[numLines - 1].RemoveControls();
                lines = newLines;

                // having now that we are below the maxLines, if the scroll buttons are visible, we should hide them
                HideScrollButtons(); 
            }            
            
            // Now remove the change that was represented by this line, even if we don't remove the line
            RemoveBatchChange(line.GetLabel());
            // having removed the change, we should update the lines
            UpdateLines();
        }

        public void RemoveBatchChange(string lineText)
        {
            Log.updateLog(Log.LogType.CLICK, "Preparing to remove change");
            int numChanges = changes.Length;
            Log.updateLog(Log.LogType.LOOPS, "Current number of changes: " + numChanges);
            if (changes.Length == 0)
                return;

            BatchChange[] newChanges = new BatchChange[numChanges - 1];
            int newIndex = 0;
            bool removed = false;
            Log.updateLog(Log.LogType.LOOPS, "Looping through changes");
            for (int changesIndex = 0; changesIndex < numChanges; changesIndex++)
            {
                Log.updateLog(Log.LogType.LOOPS, "newIndex: " + newIndex + " | changesIndex: " + changesIndex);
                if (!removed)
                {
                    Log.updateLog(Log.LogType.LOOPS, "Have not found a match");
                    if (changes[changesIndex].GetLabelText(maxLabelLength).Equals(lineText))
                    {

                        Log.updateLog(Log.LogType.LOOPS, "Match Found!");
                        removed = true;
                    }
                    else
                    {
                        newChanges[newIndex] = changes[changesIndex];
                        newIndex++;
                    }
                }
                else
                {

                    newChanges[newIndex] = changes[changesIndex];
                    newIndex++;
                }
            }
            changes = newChanges;
        }

        public void AddChange(string source, BatchChange.Operator operation, string value)
        {
            BatchChange change = new BatchChange();
            change.source = source;
            change.operation = operation;
            change.SetValue(value);
            AppendChange(change);
        }
        public void AddChange(string source, BatchChange.Operator operation, float value)
        {
            BatchChange change = new BatchChange();
            change.source = source;
            change.operation = operation;
            change.SetValue(value);
            AppendChange(change);
        }
        public void AddChange(string source, BatchChange.Operator operation, bool value)
        {
            BatchChange change = new BatchChange();
            change.source = source;
            change.operation = operation;
            change.SetValue(value);
            AppendChange(change);
        }

        public void AppendChange(BatchChange change)
        {
            Log.updateLog(Log.LogType.CLICK, "Attempting to append change");
            int numChanges = changes.Length;
            BatchChange[] newChanges = new BatchChange[numChanges + 1];
            for (int i = 0; i < numChanges; i++)
            {
                newChanges[i] = changes[i];
            }

            newChanges[numChanges] = change;
            changes = newChanges;
            Log.updateLog(Log.LogType.CLICK, "Appended the change to changes");
            // If we do not have the max number of lines, add one
            if (lines.Length < maxLines)
            {
                AddChangeLine(change);
            }
            // if we do have the max number of lines, we should scroll down one
            else
            {
                scrollUpButton.Show();
                scrollDownButton.Show();               
                Log.updateLog(Log.LogType.CLICK, "Attempting to scroll down instead of adding a new change line");
                ScrollToBottom();
            }
        }

        public void AddChangeLine(BatchChange change)
        {
            Log.updateLog(Log.LogType.CLICK, "Attempting to add a new change line");
            int numLines = lines.Length;

            // The first line is special
            // We just create it and return because we don't need to copy an array nor do we need to verify maxLines
            if (numLines == 0)
            {
                Log.updateLog(Log.LogType.CLICK, "This is the first change line to be created");
                lines = new BatchEditLine[1];
                lines[0] = new BatchEditLine(x, y, RemoveBatchEditLine, mainWindow);
                lines[0].SetLabel(change.GetLabelText(maxLabelLength));
                lines[0].Show();
                labelHeight = lines[0].GetLabelHeight();
                return;
            }

            Log.updateLog(Log.LogType.CLICK, "Current total of lines: " + numLines);
            BatchEditLine[] newLines = new BatchEditLine[numLines + 1];
            for (int i = 0; i < numLines; i++)
            {
                newLines[i] = lines[i];
            }
            Log.updateLog(Log.LogType.CLICK, "Creating new line");
            // Create a new line using the provided change 
            BatchEditLine lastLine = newLines[numLines - 1];
            BatchEditLine newLine = new BatchEditLine(
                lastLine.x,
                lastLine.y + labelHeight + verticalSpacing,
                RemoveBatchEditLine, mainWindow);

            newLine.SetLabel(change.GetLabelText(maxLabelLength));
            newLine.Show();
            newLines[numLines] = newLine;
            lines = newLines;
        }

        public void ClearBatchChanges()
        {
            // First remove all the batch lines from main window
            foreach (BatchEditLine line in lines)
            {
                line.RemoveControls();
            }
            
            // Then empty both arrays
            changes = new BatchChange[0];
            lines = new BatchEditLine[0];
            // Hide the UI
            Hide();
            // Reset the scrollIndex
            scrollIndex = 0;
        }

        public BatchChange[] GetChanges()
        {
            return changes;
        }

        public void ScrollUp(Object sender, EventArgs e)
        {
            // can't scroll up if already at the top
            if (scrollIndex == 0)
                return;
            scrollIndex--;
            UpdateLines();
        }

        public void ScrollDown(Object sender, EventArgs e)
        {
            // Can't scroll down if already at the bottom
            if (scrollIndex + maxLines + 1 > changes.Length)
                return;
            scrollIndex++;
            UpdateLines();
        }

        public void ScrollToBottom()
        {
            scrollIndex = changes.Length - maxLines;
            UpdateLines();
        }

        public void HideScrollButtons()
        {
            Log.updateLog(Log.LogType.HIDE, "Hiding Scroll Buttons");
            scrollUpButton.Hide();
            scrollDownButton.Hide();
            // If we are hiding the scroll buttons, we should return to a scroll Index of 0
            scrollIndex = 0;
        }

        public void UpdateLines()
        {
            Log.updateLog(Log.LogType.CLICK, "Updating the lines with new labels");
            // Loop through the lines
            // assign each line the label of the change at index = scrollIndex + i
            int numLines = lines.Length;
            Log.updateLog(Log.LogType.LOOPS, "lines: " + numLines + " | changes: " + changes.Length + " | scrollIndex: " + scrollIndex);
            if (scrollIndex + numLines > changes.Length)
            {
                Log.updateLog(Log.LogType.LOOPS, "New scrollIndex: " + scrollIndex);
                scrollIndex = changes.Length - numLines;
            }
            for(int i = 0; i < numLines; i++)
            {
                lines[i].SetLabel(changes[scrollIndex + i].GetLabelText(maxLabelLength));
            }
            Log.updateLog(Log.LogType.LOOPS, "Completed Line Updated");
        }

        public void Hide()
        {
            Log.updateLog(Log.LogType.HIDE, "Hiding batchChangeGroupBox");
            foreach(BatchEditLine line in lines)
            {
                line.Hide();
            }

            if (scrollUpButton != null)
            {
                scrollUpButton.Hide();
                scrollDownButton.Hide();
            }
        }

        public void Show()
        {
            Log.updateLog(Log.LogType.SHOW, "Showing batchChangeGroupBox");
            foreach (BatchEditLine line in lines)
            {
                line.Show();
            }

            if (changes.Length >= maxLines)
            {
                scrollUpButton.Show();
                scrollDownButton.Show();
            }
        }

    }
}
